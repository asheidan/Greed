Loaded suite /usr/bin/rcov
Started
...........................................................................................
Finished in 0.033658 seconds.

91 tests, 112 assertions, 0 failures, 0 errors
================================================================================
lib/monkeys/array_helper.rb
================================================================================
   class Array
     def sum
       result = 0
       each do |e|
         result += e
       end
       result
     end
   
     def freq
       f = {}
       each do |e|
         f[e] = f[e].to_i + 1 
       end
       f
     end
     
     def remove_three!(n)
       remove!(n,3)
     end
     
     def remove!(element,number)
       reject! do |e|
         if e == element then
           if number <= 0 then
             false
           else
             number -= 1
             true
           end
         else
           false
         end
       end
     end
     
   end
================================================================================
lib/players/clever_player.rb
================================================================================
   require 'players/dummy_player'
   require 'players/gambler_player'
   
   module Players
     # CleverPlayer plays differently depending on the current position.
     # When it is not in the leading position it will take high risks and
     # try to win as fast as possible. When it is leading it will save 
     # direcly and not take any risks.
     class CleverPlayer < DummyPlayer
       def roll(dice)
         if position < 1.0
           GamblerPlayer.new.roll(dice)
         else
           []
         end
       end
       
       # Calculates the position of the player normalized against the leading
       # and the lest player.
       def position
         if !@scores.nil? and @scores.include? @name
           (@scores[@name] - @scores.values.min) / (@scores.values.max - @scores.values.min)
         else
           1.0
         end
       end
       
       def update_scoreboard(scores = {})
         @scores = scores
       end
     end
   end
================================================================================
lib/players/coward_player.rb
================================================================================
   require 'players/dummy_player'
   
   module Players
   	class CowardPlayer < DummyPlayer
   		def roll(dice)
   			[]
   		end	
   	end
   end
================================================================================
lib/players/dummy_player.rb
================================================================================
   module Players
     
     # Inherit this class and override the methods you want/need/like
     class DummyPlayer
       
       def initialize(name = '')
         @name = name
         @limit = 10000
         @bust = 300
       end
       
       # Called by server with information about all players scores
       def update_scoreboard(scores = {})
       end
       
       # Called by server with information about current turn
       def status_update(name, dice, saved=[])
       end
       
       # Called by server when it's this players turn.
       # The method returns an Array with the dice the player want's to throw
       # again and an empty Array when it's time to save.
       def roll(dice)
         dice
       end
       
       # Called by server when a joining a game.
       def limits(limit,bust)
         @limit = limit
         @bust = bust
       end
       
       # Just a string representing your name, should be unique
       def name
         @name.empty? ? to_s : @name
       end
     end
   end
================================================================================
lib/players/gambler_player.rb
================================================================================
   require 'players/dummy_player'
   require 'monkeys/array_helper'
   
   module Players
     
     # GamblerPlayer implements a foolheardy greed-player
     # Gambler saves Street and 3 of a kind. Right now the player doesn't
     # reroll everything if it gets a street or points on all af the dice
     class GamblerPlayer < DummyPlayer
       def roll(dice)
         dice = dice.clone
         if dice.sort == [1,2,3,4,5,6] # Street
           dice = []
         elsif dice.count >= 3
           dice.freq.to_a.collect do |k,v|
             if v == 6 then
               [k,k]
             elsif v >= 3 then
               k
             end
           end.compact.flatten.each{|k| dice.remove_three!(k) }
         end
         dice.reject{|die| die == 1 || die == 5 }
       end
     end
   end
================================================================================
lib/players/random_player.rb
================================================================================
   require 'players/dummy_player'
   require 'players/gambler_player'
   require 'players/coward_player'
   
   module Players
     # RandomPlayer randombly creates other players and asks them
     # what they would do and acts according to that.
     class RandomPlayer < DummyPlayer
       def roll(dice)
         player_types = [GamblerPlayer, DummyPlayer, CowardPlayer]
         player_types[rand(player_types.length)].new.roll(dice)
       end
     end
   end
================================================================================
lib/rules.rb
================================================================================
   
   module Rules
     def self.apply_rules(dice)
       rules.collect { |rule|
         # TODO: Object creation in Ruby isn't great, possible optimization here
         points, unused = rule.new.apply(dice)
         if points == 0 then
           [0,dice]
         elsif unused.empty? then
           [points, []]
         else
           other_points, unused = apply_rules(unused)
           [(points+other_points), unused]
         end
       }.max { |a,b| a.first <=> b.first }
     end
     
     def self.max_points(dice)
       apply_rules(dice).first
     end
     
     # Returns a sorted Array with all Classes in this module (no submodules)
     def self.rules
       self.constants.sort.collect do |const_name|
         c = self.const_get( const_name )
         c if c.is_a? Class
       end
     end
   end
================================================================================
lib/rules/dummy_rule.rb
================================================================================
   module Rules
     class DummyRule
       
       # All Rule-classes implements this method. The argument is a set of dice
       # and the return value should be a tuple where the first value is the
       # maximum points for this rule and the given dice and the second value
       # is an Array of the dice not used
       def apply(dice)
         return 0,[]
       end
     end
   end
================================================================================
lib/rules/ones_and_fives_rule.rb
================================================================================
   module Rules
     class OnesAndFivesRule
       def apply(dice)
         points = 0
         rethrow = dice.select do |die|
           if die == 1
             points += 100
             false
           elsif die == 5
             points += 50
             false
           else
             true
           end
         end
         return points,rethrow
       end
     end
   end
================================================================================
lib/rules/street_rule.rb
================================================================================
   module Rules
     class StreetRule
       
       def apply(dice)
         if dice.sort == [1,2,3,4,5,6]
           return 1000,[]
         else
           return 0,dice
         end
       end
     end
   end
================================================================================
lib/rules/three_of_a_kind_rule.rb
================================================================================
   require 'monkeys/array_helper'
   
   module Rules
     class ThreeOfAKindRule
       def apply(dice)
         dice = dice.clone
         points = 0
         dice.freq.to_a.collect{|k,v| k if v >= 3}.compact.each do |k|
           points += points_table(k)
           dice.remove_three!(k)
         end
         return points, dice
       end
       
       private
       def points_table(n)
         if n == 1 then
           1000
         else
           n * 100
         end
       end
     end
   end
================================================================================
lib/server.rb
================================================================================
   require 'drb/drb'
   require 'logger'
   require 'rules'
   require 'rules/ones_and_fives_rule'
   require 'rules/three_of_a_kind_rule'
   require 'rules/street_rule'
   
   # $SAFE = 1
   
   $log = Logger.new(STDERR)
   $log.datetime_format = "%Y-%m-%d %H:%M:%S"
   
   class Server
     # Makes this class unserializeable (object will not be sent over network)
     include DRbUndumped
     
     attr_reader :uri, :score_board
     
     def initialize(port=nil)
       $log.debug('initialize') { "port: #{port}" }
       @mutex = Mutex.new
       @clients = []
       @score_board = {}
       @uri = port.nil? ? nil : "druby://localhost:#{port}"
       
       @bust = 300
       @limit = 10000
     end
     
     def start_service
!!     DRb.start_service(uri,self)
!!   end
     
     def stop_service
!!     DRb.stop_service
!!   end
     
     # Remotely called
     
     # Connects a client to the server and adds it to the game.
     def connect(client)
       $log.debug('connect'){ "Client connected: #{client.inspect}" }
       
       # Maybe this should run in another thread so this returns
       # and player receives limits when it's added.
       @mutex.synchronize {
         @clients << client
         @score_board[client.name] = 0
       }
       client.limits(@limit,@bust)
     end
     
     def start_game
       @mutex.synchronize{
         @clients.shuffle!
       }
       game
     end
     
     # Calls the specified method in all clients except those in except
     # with the given parameters.
     def broadcast(method, parameters, except=[])
       # @mutex.synchronize {
         @clients.each do |c|
           if( !except.include? c ) then
             begin
               # $log.debug parameters
               c.send(method,*parameters)
!!           rescue DRb::DRbError => e
!!             $log.error('broadcast') { "Removing #{c.inspect} #{e.message}" }
!!             @clients.delete c
!!           end
!!         end
!!       end
!!     # }
!!   end
     private :broadcast
     
     # Sketch for game round. @clients should be shuffle!d before each game.
     def game
       # Just one round implemented for now
       loop do
         @mutex.synchronize {
           @clients.each { |c|
             broadcast(:update_scoreboard, [@score_board])
             round_score = 0
             saved_dice = throw_dice = []
             decision = [nil] * 6
             while decision != [] do
               rethrow_count = 6 - saved_dice.length
               throw_dice = decision.collect{|d| rand(6)+1 }.sort[0..(rethrow_count-1)]
               $log.debug('game: dice') {throw_dice}
               broadcast(:status_update, [c.name, throw_dice], [c])
               decision = c.roll(throw_dice)
               decision.each{ |d|
!!               throw_dice.remove!(d,1)
!!             }
               broadcast(:status_update, [c.name, throw_dice, saved_dice], [c])
               # Calculate score for saved dice
               throw_score = Rules.max_points( throw_dice )
               if round_score == 0 then
                 if (throw_score >= @bust) then
                   round_score += throw_score
                   saved_dice += throw_dice
                 else
                   $log.debug('game'){ "Player: #{c.name} busted" }
                   decision = []
                 end
!!             elsif throw_score > 0 then
!!               saved_dice += throw_dice
!!               round_score += throw_score
!!               if saved_dice.length == 6 then
!!                 saved_dice = []
!!               end
!!             else
!!               $log.debug('game'){ "Player: #{c.name} got no points"}
!!               round_score = 0
!!               decision = []
!!             end
!!           end
             
             @score_board[c.name] += round_score
             if @score_board[c.name] >= @limit then
               $log.debug('game'){ "#{c.name} won!"}
               return c
             end
           }
           sleep 1 if @clients.empty?
         }
       end
     end
     private :game
   end
   
   # This section is true when running ruby "this file"
   if __FILE__ == $0
!!   server = Server.new(8787)
!!   DRb::DRbServer.verbose = true
!!   server.start_service
!! 
!!   $log.info "Service started"
!!   $log.info server.uri
!!   DRb.thread.join
!! end
